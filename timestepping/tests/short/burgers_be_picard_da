#!/usr/bin/env python3

# Copyright (C) 2011-2012 by Imperial College London
# Copyright (C) 2013 University of Oxford
# Copyright (C) 2014, 2017 The University of Edinburgh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, version 3 of the License
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Based on burgers_newton.py test from dolfin-adjoint
# Code first added: 2012-10-25

from dolfin import *
from dolfin_adjoint_timestepping import *

import numpy

parameters["reorder_dofs_serial"] = False

ngrid = 30
nu = StaticConstant(0.0001)
dt = StaticConstant(1.0 / ngrid)
t_end = 0.2

mesh = UnitIntervalMesh(ngrid)
space = FunctionSpace(mesh, "CG", 2)
test, trial = TestFunction(space), TrialFunction(space)

ic = StaticFunction(space, name = "initial_condition")
ic.assign(project(Expression("sin(2.0 * pi * x[0])", element = space.ufl_element()), space))

system = TimeSystem()
levels = TimeLevels(levels = [n, n + 1], cycle_map = {n:n + 1})
u = TimeFunction(levels, space, name = "u")
system.add_solve(inner(test, trial) * dx == inner(test, ic) * dx, u[0], StaticDirichletBC(space, 0.0, "on_boundary"))
class CustomSolver(EquationSolver):
  def __init__(self):
    EquationSolver.__init__(self,
                            eq = (test * (u[n + 1] - u[n]) / dt + test * dot(as_vector([u[n + 1]]), grad(u[n + 1])) + nu * dot(grad(test), grad(u[n + 1]))) * dx == 0,
                            x = u[n + 1],
                            bcs = [StaticDirichletBC(space, 0.0, "on_boundary")],
                            solver_parameters = {"newton_solver":{"linear_solver":"lu"}})
    self.__x_1 = x_1 = dolfin.Function(u[n + 1].function_space())
    self.__x_2 = dolfin.Function(u[n + 1].function_space())
    self.__picard_lhs = test * trial * dx + dt * (test * dot(as_vector([x_1]), grad(trial)) + nu * dot(grad(test), grad(trial))) * dx
    self.__picard_rhs = (test * u[n]) * dx
    self.__solver = LinearSolver({"linear_solver":"lu"})
    return
  def solve(self):
    x, bcs = self.x(), self.bcs()
    x_1, x_2, lhs, rhs, solver = self.__x_1, self.__x_2, self.__picard_lhs, self.__picard_rhs, self.__solver
    x_1.assign(x)
    max_it = 200
    it = 0
    while it < max_it:
      a = assemble(lhs)
      L = assemble(rhs)
      for bc in bcs:
        bc.apply(a, L)
      solver.set_operator(a)
      solver.solve(x_2.vector(), L)
      it += 1
      if (x_1.vector() - x_2.vector()).norm("linf") < 1.0e-15:
        break
      x_1.assign(x_2)
    assert(it < max_it)
    x.assign(x_2)
    return
system.add_solve(CustomSolver())

system = system.assemble(adjoint = True, disk_period = 2)
t = 0.0
while t <= t_end:
  system.timestep()
  t += float(dt)
system.finalise()
parameters["adjoint"]["stop_annotating"] = True

dolfin_adjoint_solution = numpy.array(list(map(float, """0.00000000e+00   4.83691942e-02   9.27158413e-02   1.34969515e-01
   1.75870219e-01   2.14962421e-01   2.51429538e-01   2.84190750e-01
   3.11875289e-01   3.32720537e-01   3.44371971e-01   3.43502382e-01
   3.25028855e-01   2.80253426e-01   1.91216166e-01   4.35048117e-15
  -1.91216166e-01  -2.80253426e-01  -3.25028855e-01  -3.43502382e-01
  -3.44371971e-01  -3.32720537e-01  -3.11875289e-01  -2.84190750e-01
  -2.51429538e-01  -2.14962421e-01  -1.75870219e-01  -1.34969515e-01
  -9.27158413e-02  -4.83691942e-02   0.00000000e+00   5.54997205e-02
   1.67637825e-01   2.80283838e-01   3.91486149e-01   5.00454502e-01
   6.06508717e-01   7.08950439e-01   8.06992584e-01   8.99691662e-01
   9.85857768e-01   1.06391145e+00   1.13162598e+00   1.18559976e+00
   1.21996622e+00   1.22215187e+00  -1.22215187e+00  -1.21996622e+00
  -1.18559976e+00  -1.13162598e+00  -1.06391145e+00  -9.85857768e-01
  -8.99691662e-01  -8.06992584e-01  -7.08950439e-01  -6.06508717e-01
  -5.00454502e-01  -3.91486149e-01  -2.80283838e-01  -1.67637825e-01
  -5.54997205e-02""".split())), dtype = numpy.float64)
err = abs(u[N].vector().array() - dolfin_adjoint_solution).max()
print(u[N].vector().array(), err)
assert(err < 5.0e-9)

system.verify_checkpoints()

system.set_functional(u[N] * u[N] * dx)
J = system.compute_functional()
grad = system.compute_gradient([ic, nu])
dolfin_adjoint_grad = numpy.array(list(map(float, """8.59078516e-06   5.14455129e-03   9.68714533e-03   1.32638583e-02
   1.57235638e-02   1.70566231e-02   1.73441017e-02   1.67252969e-02
   1.53773141e-02   1.35014696e-02   1.13129182e-02   9.03074645e-03
   6.86570301e-03   5.00211810e-03   3.67560774e-03  -9.36208576e-17
  -3.67560774e-03  -5.00211810e-03  -6.86570301e-03  -9.03074645e-03
  -1.13129182e-02  -1.35014696e-02  -1.53773141e-02  -1.67252969e-02
  -1.73441017e-02  -1.70566231e-02  -1.57235638e-02  -1.32638583e-02
  -9.68714533e-03  -5.14455129e-03  -8.59078516e-06   5.18311244e-03
   1.49232138e-02   2.30720516e-02   2.91233827e-02   3.29220869e-02
   3.45434926e-02   3.42106908e-02   3.22422847e-02   2.90188883e-02
   2.49597062e-02   2.05030718e-02   1.60857840e-02   1.21149447e-02
   8.91738577e-03   6.08307673e-03  -6.08307673e-03  -8.91738577e-03
  -1.21149447e-02  -1.60857840e-02  -2.05030718e-02  -2.49597062e-02
  -2.90188883e-02  -3.22422847e-02  -3.42106908e-02  -3.45434926e-02
  -3.29220869e-02  -2.91233827e-02  -2.30720516e-02  -1.49232138e-02
  -5.18311244e-03""".split())), dtype = numpy.float64)
err = abs(grad[0].array() - dolfin_adjoint_grad).max()
print(grad[0].array(), err)
assert(err < 5.0e-11)

orders = system.taylor_test(ic, J = J, grad = grad[0])
assert((orders > 2.0).all())

orders = system.taylor_test(nu, J = J, grad = grad[1])
assert((orders > 1.99).all())

assert(replay_dolfin(forget = False, tol = 4.0e-11, stop = True))

grad_da = compute_gradient(Functional(u[N] * u[N] * dx * dolfin_adjoint.dt[FINISH_TIME]), [Control(ic), Control(nu)])

err = (grad[0] - grad_da[0].vector()).norm("linf")
print("%s %.16e" % (grad_da[0].vector().array(), err))
assert(err < 1.0e-12)

err = abs(float(grad[1]) - float(grad_da[1]))
print("%.16e %.16e" % (grad_da[1], err))
assert(err < 2.0e-9)
