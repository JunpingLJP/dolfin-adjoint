#!/usr/bin/env python3

# Copyright (C) 2011-2012 by Imperial College London
# Copyright (C) 2013 University of Oxford
# Copyright (C) 2014, 2017 The University of Edinburgh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, version 3 of the License
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Based on burgers_newton.py test from dolfin-adjoint
# Code first added: 2012-10-25

from dolfin import *
from timestepping import *

import numpy

parameters["reorder_dofs_serial"] = False

ngrid = 30
nu = StaticConstant(0.0001)
dt = StaticConstant(0.05 / ngrid)
t_end = 0.2

mesh = UnitIntervalMesh(ngrid)
space = FunctionSpace(mesh, "CG", 2)
test, trial = TestFunction(space), TrialFunction(space)

ic = StaticFunction(space, name = "initial_condition")
ic.assign(project(Expression("sin(2.0 * pi * x[0])", element = space.ufl_element()), space))

system = TimeSystem()
levels   = TimeLevels(levels = [n - 2, n - 1, n, n + 1], cycle_map = {n - 2:n - 1, n - 1:n, n:n + 1})
levels_F = TimeLevels(levels = [n - 2, n - 1, n], cycle_map = {n - 2:n - 1, n - 1:n}, last_past_level = n - 1)
u = TimeFunction(levels,   space, name = "u")
F = TimeFunction(levels_F, space, name = "F")
def rhs(n):
  return - dt * (inner(test, dot(as_vector([u[n]]), grad(u[n]))) + nu * inner(grad(test), grad(u[n]))) * dx
def add_F_solve(n):
  system.add_solve(inner(test, trial) * dx == rhs(n),
    F[n],
    StaticDirichletBC(space, 0.0, "on_boundary"), solver_parameters = {"linear_solver":"lu"})
  return
  
system.add_solve(inner(test, trial) * dx == inner(test, ic) * dx, u[-2], StaticDirichletBC(space, 0.0, "on_boundary"))
add_F_solve(-2)
system.add_solve(inner(test, trial) * dx == inner(test, u[-2]) * dx + inner(test, F[-2]) * dx,
  u[-1],
  StaticDirichletBC(space, 0.0, "on_boundary"), solver_parameters = {"linear_solver":"lu"})
add_F_solve(-1)
system.add_solve(LinearCombination((1.5, F[-1]), (-0.5, F[-2]), (1.0, u[-1])), u[0])
add_F_solve(n)
system.add_solve(LinearCombination(((23.0 / 12.0), F[n]), \
                                   ((-4.0 / 3.0), F[n - 1]), \
                                   ((5.0 / 12.0), F[n - 2]), \
                                   (1.0, u[n])), u[n + 1])

system = system.assemble(adjoint = True, disk_period = 10)
t = 2.0 * float(dt)
while t <= t_end:
  system.timestep()
  t += float(dt)
system.finalise()

dolfin_adjoint_solution = numpy.array(list(map(float, """0.00000000e+00   9.18803519e-02   1.83760123e-01   2.73860402e-01
   3.61117100e-01   4.42520270e-01   5.13747015e-01   5.69016460e-01
   6.02622078e-01   6.10779013e-01   5.92896048e-01   5.51017140e-01
   4.87316935e-01   3.99651530e-01   2.71421978e-01   8.57378946e-15
  -2.71421978e-01  -3.99651530e-01  -4.87316935e-01  -5.51017140e-01
  -5.92896048e-01  -6.10779013e-01  -6.02622078e-01  -5.69016460e-01
  -5.13747015e-01  -4.42520270e-01  -3.61117100e-01  -2.73860402e-01
  -1.83760123e-01  -9.18803519e-02   0.00000000e+00   4.67068636e-02
   1.39469334e-01   2.31986652e-01   3.24146124e-01   4.16284339e-01
   5.09503200e-01   6.05496476e-01   7.06191185e-01   8.12622547e-01
   9.23868598e-01   1.03651828e+00   1.14487754e+00   1.24116799e+00
   1.31415300e+00   1.34143183e+00  -1.34143183e+00  -1.31415300e+00
  -1.24116799e+00  -1.14487754e+00  -1.03651828e+00  -9.23868598e-01
  -8.12622547e-01  -7.06191185e-01  -6.05496476e-01  -5.09503200e-01
  -4.16284339e-01  -3.24146124e-01  -2.31986652e-01  -1.39469334e-01
  -4.67068636e-02""".split())), dtype = numpy.float64)
err = abs(u[N].vector().array() - dolfin_adjoint_solution).max()
print(u[N].vector().array(), err)
assert(err < 5.0e-9)

system.verify_checkpoints()

system.set_functional(u[N] * u[N] * dx)
J = system.compute_functional()
grad = system.compute_gradient([ic, nu])
dolfin_adjoint_grad = numpy.array(list(map(float, """2.44696584e-06   4.62778231e-03   9.05327670e-03   1.30828981e-02
   1.65397448e-02   1.92710989e-02   2.11534091e-02   2.21051321e-02
   2.20789095e-02   2.09881480e-02   1.72884404e-02   1.26928993e-02
   8.84210646e-03   5.61471808e-03   2.73545940e-03  -2.81621514e-17
  -2.73545940e-03  -5.61471808e-03  -8.84210646e-03  -1.26928993e-02
  -1.72884404e-02  -2.09881480e-02  -2.20789095e-02  -2.21051321e-02
  -2.11534091e-02  -1.92710989e-02  -1.65397448e-02  -1.30828981e-02
  -9.05327670e-03  -4.62778231e-03  -2.44696584e-06   4.63770479e-03
   1.37101889e-02   2.21833195e-02   2.96857954e-02   3.58869851e-02
   4.05111102e-02   4.33570780e-02   4.42398961e-02   4.32491199e-02
   3.85439249e-02   2.99112918e-02   2.14641812e-02   1.44298399e-02
   8.33993254e-03   2.76684061e-03  -2.76684061e-03  -8.33993254e-03
  -1.44298399e-02  -2.14641812e-02  -2.99112918e-02  -3.85439249e-02
  -4.32491199e-02  -4.42398961e-02  -4.33570780e-02  -4.05111102e-02
  -3.58869851e-02  -2.96857954e-02  -2.21833195e-02  -1.37101889e-02
  -4.63770479e-03""".split())), dtype = numpy.float64)
err = abs(grad[0].array() - dolfin_adjoint_grad).max()
print(grad[0].array(), err)
assert(err < 5.0e-11)

orders = system.taylor_test(ic, J = J, grad = grad[0])
assert((orders > 1.99).all())

orders = system.taylor_test(nu, J = J, grad = grad[1])
assert((orders > 1.99).all())
